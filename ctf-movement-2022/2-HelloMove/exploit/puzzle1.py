#!/usr/bin/env python3
"""
4-byte brute force attack for Move CTF hash challenge
Target: Find 4 bytes that when appended with "move" produces the target Keccak256 hash
"""

import hashlib
import time

# Try to import pycryptodome, fallback to hashlib if not available
try:
    from Crypto.Hash import keccak
    def keccak256(data):
        """Calculate Keccak256 hash using pycryptodome"""
        k = keccak.new(digest_bits=256)
        k.update(data)
        return k.hexdigest()
    print("‚úÖ Using pycryptodome for Keccak256")
except ImportError:
    print("‚ö†Ô∏è  pycryptodome not found, using hashlib sha3_256 (may not match exactly)")
    def keccak256(data):
        """Fallback: Use SHA3-256 (close to Keccak256 but not identical)"""
        return hashlib.sha3_256(data).hexdigest()

def brute_force_4_bytes():
    """Full 4-byte brute force attack"""
    target_hash = "d9ad5396ce1ed307e8fb2a90de7fd01d888c02950ef6852fbc2191d2baf58e79"
    move_suffix = b"move"  # [109, 111, 118, 101]
    
    print("üöÄ Starting 4-byte brute force attack...")
    print(f"Target hash: {target_hash}")
    print("This will try 2^32 = 4,294,967,296 combinations")
    print("Estimated time: Several hours to days depending on CPU")
    print("-" * 60)
    
    start_time = time.time()
    attempts = 0
    
    # Try all 4-byte combinations (0x00000000 to 0xFFFFFFFF)
    for i in range(2**32):
        # Convert to 4 bytes (big endian)
        four_bytes = i.to_bytes(4, 'big')
        
        # Append "move"
        full_input = four_bytes + move_suffix
        
        # Calculate Keccak256
        hash_result = keccak256(full_input)
        attempts += 1
        
        # Check if matches target
        if hash_result == target_hash:
            elapsed = time.time() - start_time
            print(f"\nüéâ FOUND THE ANSWER!")
            print(f"4-byte input: {list(four_bytes)} (decimal)")
            print(f"4-byte input: {four_bytes.hex()} (hex)")
            print(f"4-byte input: '{four_bytes.decode('utf-8', errors='ignore')}' (ascii)")
            print(f"Full input: {list(full_input)}")
            print(f"Hash: {hash_result}")
            print(f"Attempts: {attempts:,}")
            print(f"Time taken: {elapsed:.2f} seconds")
            return four_bytes
        
        # Progress update every 10 million attempts
        if attempts % 10_000_000 == 0:
            elapsed = time.time() - start_time
            rate = attempts / elapsed if elapsed > 0 else 0
            progress = (attempts / (2**32)) * 100
            print(f"Progress: {progress:.6f}% | Attempts: {attempts:,} | Rate: {rate:.0f}/sec | Time: {elapsed:.0f}s")
    
    print("Brute force completed. No match found.")
    return None

def try_common_words():
    """Try common 4-letter words first (optimization)"""
    target_hash = "d9ad5396ce1ed307e8fb2a90de7fd01d888c02950ef6852fbc2191d2baf58e79"
    move_suffix = b"move"
    
    # Common 4-letter words and patterns
    common_words = [
        b"good", b"best", b"test", b"flag", b"code", b"hack", b"ctf!", b"win!",
        b"love", b"game", b"play", b"cool", b"nice", b"fire", b"rock", b"star",
        b"hero", b"king", b"boss", b"epic", b"fast", b"big!", b"safe", b"lock",
        b"key!", b"pass", b"word", b"hash", b"sha3", b"move", b"aptos", b"sui!",
        # Hex patterns
        b"\x00\x00\x00\x01", b"\x00\x00\x00\x02", b"\x00\x00\x01\x00",
        b"\x01\x02\x03\x04", b"\xff\xff\xff\xff", b"\xde\xad\xbe\xef",
        # ASCII patterns  
        b"1234", b"abcd", b"ABCD", b"0000", b"1111", b"aaaa", b"AAAA"
    ]
    
    print("üîç Trying common 4-byte patterns first...")
    
    for i, word in enumerate(common_words):
        # Ensure exactly 4 bytes
        if len(word) < 4:
            four_bytes = word + b'\x00' * (4 - len(word))  # Pad with null bytes
        elif len(word) > 4:
            four_bytes = word[:4]  # Truncate to 4 bytes
        else:
            four_bytes = word
        
        # Append "move"
        full_input = four_bytes + move_suffix
        
        # Calculate hash
        hash_result = keccak256(full_input)
        
        print(f"[{i+1:2d}] Trying: {list(four_bytes)} -> {hash_result[:16]}...")
        
        if hash_result == target_hash:
            print(f"\nüéâ FOUND with common word!")
            print(f"Word: {word}")
            print(f"4-byte input: {list(four_bytes)}")
            print(f"Full input: {list(full_input)}")
            print(f"Hash: {hash_result}")
            return four_bytes
    
    print("‚ùå Common words failed. Need full brute force.")
    return None

def verify_known_answer():
    """Verify the known answer 'good' works"""
    good_bytes = b"good"  # [103, 111, 111, 100]
    move_suffix = b"move"  # [109, 111, 118, 101]
    full_input = good_bytes + move_suffix
    
    hash_result = keccak256(full_input)
    target_hash = "d9ad5396ce1ed307e8fb2a90de7fd01d888c02950ef6852fbc2191d2baf58e79"
    
    print("‚úÖ Verifying known answer 'good':")
    print(f"Input bytes: {list(full_input)}")
    print(f"Hash: {hash_result}")
    print(f"Target: {target_hash}")
    print(f"Match: {hash_result == target_hash}")
    
    return hash_result == target_hash

def optimized_search():
    """Optimized search focusing on ASCII printable characters"""
    target_hash = "d9ad5396ce1ed307e8fb2a90de7fd01d888c02950ef6852fbc2191d2baf58e79"
    move_suffix = b"move"
    
    print("üéØ Optimized search: ASCII printable characters (32-126)")
    
    start_time = time.time()
    attempts = 0
    
    # Focus on printable ASCII (32-126)
    for b1 in range(32, 127):
        for b2 in range(32, 127):
            for b3 in range(32, 127):
                for b4 in range(32, 127):
                    four_bytes = bytes([b1, b2, b3, b4])
                    full_input = four_bytes + move_suffix
                    
                    hash_result = keccak256(full_input)
                    attempts += 1
                    
                    if hash_result == target_hash:
                        elapsed = time.time() - start_time
                        print(f"\nüéâ FOUND!")
                        print(f"4-byte input: {list(four_bytes)}")
                        print(f"ASCII: '{four_bytes.decode('ascii')}'")
                        print(f"Hash: {hash_result}")
                        print(f"Attempts: {attempts:,}")
                        print(f"Time: {elapsed:.2f}s")
                        return four_bytes
                    
                    if attempts % 100000 == 0:
                        elapsed = time.time() - start_time
                        rate = attempts / elapsed if elapsed > 0 else 0
                        total_ascii = 95**4  # (127-32)^4
                        progress = (attempts / total_ascii) * 100
                        print(f"Progress: {progress:.2f}% | Attempts: {attempts:,} | Rate: {rate:.0f}/sec")
    
    print("ASCII search completed. No match found.")
    return None

if __name__ == "__main__":
    print("Move CTF - Hash Challenge Brute Force Tool")
    print("=" * 50)
    
    # Step 1: Verify known answer
    if verify_known_answer():
        print("\n‚úÖ Known answer 'good' is correct!")
        print("Move code: vector[103, 111, 111, 100]")
        exit(0)
    
    # Step 2: Try common words
    result = try_common_words()
    if result:
        exit(0)
    
    # Step 3: Optimized ASCII search
    print("\n" + "="*50)
    result = optimized_search()
    if result:
        exit(0)
    
    # Step 4: Full brute force (last resort)
    print("\n" + "="*50)
    choice = input("No luck with optimized search. Try full brute force? (y/N): ")
    if choice.lower() == 'y':
        brute_force_4_bytes()
